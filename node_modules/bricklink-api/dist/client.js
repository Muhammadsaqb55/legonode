"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Client = void 0;
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _oAuthHelper = require("./oAuthHelper");
var _catalogItem = require("./catalogItem/catalogItem");
var _priceGuide = require("./catalogItem/priceGuide");
var _knownColor = require("./catalogItem/knownColor");
var _itemImage = require("./catalogItem/itemImage");
var _subsets = require("./catalogItem/subsets");
var _supersets = require("./catalogItem/supersets");
var _logger = require("./logger");
var _request = require("./request");
var _brickLinkApiError = require("./brickLinkApiError");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * Create a client to perform
 */
var Client = /*#__PURE__*/function () {
  /**
   * Create an instance of the Bricklin Node Client.
   * @param {object} [options] Options that are used to create a new client.
   * @param {string} [options.token] The `TokenValue` from {@link https://www.bricklink.com/v2/api/register_consumer.page}
   * @param {string} [options.token_secret] The `TokenSecret` from {@link https://www.bricklink.com/v2/api/register_consumer.page}
   * @param {string} [options.consumer_key] The `ConsumerKey` from {@link https://www.bricklink.com/v2/api/register_consumer.page}
   * @param {string} [options.consumer_secret] The `ConsumerSecret` from {@link https://www.bricklink.com/v2/api/register_consumer.page}
   * @param {string} [options.endpoint='https://api.bricklink.com/api/store/v1/'] The url of the Bricklink API.
   */
  function Client(options) {
    _classCallCheck(this, Client);
    options = options || {};

    /** @type {string} */
    this.token = options.token || '';
    /** @type {string} */
    this.token_secret = options.token_secret || '';
    /** @type {string} */
    this.consumer_key = options.consumer_key || '';
    /** @type {string} */
    this.consumer_secret = options.consumer_secret || '';
    /** @type {string} */
    this.endpoint = options.endpoint || 'https://api.bricklink.com/api/store/v1/';
    /** @type {Function[]} */
    this.requestQueue = [];
  }

  /**
   * Performs a concurrent-safe bricklink request and the callback upon success.
   * @param {BricklinkRequest} req The request to perform.
   * @return {Promise} The data that has been return from the API request and any callbacks.
   */
  _createClass(Client, [{
    key: "send",
    value: function send(req) {
      var _this = this;
      var promise = new Promise(function (resolve, reject) {
        var callback = function callback() {
          return _this.dispatch(req).then(resolve)["catch"](reject).then(function () {
            var deleteIndex = _this.requestQueue.indexOf(callback);
            _this.requestQueue.splice(deleteIndex, 1);
            if (_this.requestQueue.length > 0) {
              var continueQueue = _this.requestQueue[0];
              continueQueue();
            }
          });
        };
        _this.requestQueue.push(callback);
        if (_this.requestQueue.length === 1) {
          var startQueue = _this.requestQueue[0];
          startQueue();
        }
      });
      return promise;
    }

    /**
     * Performs a bricklink request and the callback upon success.
     * @param {BricklinkRequest} req The request to perform.
     * @return {Promise} The data that has been return from the API request and any callbacks.
     */
  }, {
    key: "dispatch",
    value: function dispatch(req) {
      var resourceURL = this.endpoint + req.uri.replace(/^\//, '') + req.params.toQueryString();
      /** @type {RequestInit} */
      var init = {
        method: req.method,
        headers: {}
      };
      var oauthHelper = new _oAuthHelper.OAuthHelper(this.consumer_key, this.token);
      oauthHelper.sign(resourceURL, req, this.consumer_secret, this.token_secret);
      init.headers['authorization'] = oauthHelper.header;
      var promise = (0, _nodeFetch["default"])(resourceURL, init).then(function (response) {
        return response.json();
      }).then(
      /**
       * @param {any} payload Any object
       */
      function (payload) {
        if (payload.meta.code >= 300) {
          var error = new _brickLinkApiError.BrickLinkApiError(payload.meta);
          (0, _logger.logger)(JSON.stringify({
            reqestURI: resourceURL,
            responseMetadata: payload.meta
          }, null, 2));
          throw error;
        } else {
          return payload.data;
        }
      });
      promise["catch"](function (error) {
        (0, _logger.logger)(error);
      });
      if (req.callback) {
        return promise.then(req.callback);
      }
      return promise;
    }

    /**
     * Get a catalog item by type and identification number.
     * @param {string} itemType An item type as can be foud at {@link ItemType}.
     * @param {string} itemNumber An item identification number.
     * @return {Promise<CatalogItem>} A promise that resolves to a catalog item.
     */
  }, {
    key: "getCatalogItem",
    value: function getCatalogItem(itemType, itemNumber) {
      var req = _catalogItem.CatalogItem.get(itemType, itemNumber);
      return this.send(req);
    }

    /**
     * Get the price guide for a given catalog item.
     * @param {string} itemType An item type as can be foud at {@link ItemType}.
     * @param {string} itemNumber An item identification number.
     * @param {object} params Options for the price guide as outlined in {@link PriceGuideOptions}.
     * @return {Promise<PriceGuide>} A promise that resolves to a price guide.
     */
  }, {
    key: "getPriceGuide",
    value: function getPriceGuide(itemType, itemNumber, params) {
      var req = _priceGuide.PriceGuide.get(itemType, itemNumber, params);
      return this.send(req);
    }

    /**
     * Get known colors for a catalog item.
     * @param {string} itemType An item type as can be foud at {@link ItemType}.
     * @param {string} itemNumber An item identification number.
     * @return {Promise<Array>} A promise that resolves to a list of {@link KnownColor}.
     */
  }, {
    key: "getKnownColors",
    value: function getKnownColors(itemType, itemNumber) {
      var req = _knownColor.KnownColor.get(itemType, itemNumber);
      return this.send(req);
    }

    /**
     * Can get an image for a specific image color of a known catalog item.
     * @param {string} itemType An item type as can be foud at {@link ItemType}.
     * @param {string} itemNumber An item identification number.
     * @param {number} colorId The color id of the item.
     * @return {Promise<ItemImage>} A promise that resolves to an Item Image.
     */
  }, {
    key: "getItemImage",
    value: function getItemImage(itemType, itemNumber, colorId) {
      var req = _itemImage.ItemImage.get(itemType, itemNumber, colorId);
      return this.send(req);
    }

    /**
     * Gets a subset of a catalog item.
     * @param {string} itemType An item type as can be foud at {@link ItemType}.
     * @param {string} itemNumber An item identification number.
     * @param {object} [params] Options for the price guide as outlined in {@link SubsetOptions}.
     * @return {Promise<Array>} A promise that resolves to a  list of {@link Subset}.
     */
  }, {
    key: "getItemSubset",
    value: function getItemSubset(itemType, itemNumber, params) {
      var req = _subsets.Subset.get(itemType, itemNumber, params);
      return this.send(req);
    }

    /**
     * Gets a superset of a catalog item.
     * @param {string} itemType An item type as can be foud at {@link ItemType}.
     * @param {string} itemNumber An item identification number.
     * @param {object} [params] Options for the price guide as outlined in {@link SupersetOptions}.
     * @return {Promise<Array>} A promise that resolves to a  list of {@link Superset}.
     */
  }, {
    key: "getItemSuperset",
    value: function getItemSuperset(itemType, itemNumber, params) {
      var req = _supersets.Superset.get(itemType, itemNumber, params);
      return this.send(req);
    }
  }]);
  return Client;
}();
exports.Client = Client;